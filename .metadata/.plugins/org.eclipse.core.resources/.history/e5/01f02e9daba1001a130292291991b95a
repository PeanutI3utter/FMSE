/* 
   Solution identical to Crossing.pml, but it does not use the _pid variable. Instead the processes 
   are explicitly created in the separate init process.
   A car can be either: 
    - far away, 
    - stopping at crossing 
    - being on the crossing
   the transition between these states is: far -> stopping -> on crossing -> far
*/
mtype = {far, stopping, onCrossing}

#define NR_CARS 4   // number of cars; maximal four

// The chosen modelling supports at most one car per direction.
// Four directions, hence, four cars (one in each direction) max.
// Array carState represents for each direction the state of the car driving in the direction
// (0 if no car is driving in the respective direction)
// carState[0]: north-to-south, carState[1]: west-to-east, 
// carState[2]: south-to-north, carState[3]: east-to-west

mtype carState[4];  

proctype car(byte i) {
  carState[i] = far;
  carState[i] = stopping;
  atomic {
     carState[(i+1)%4] != stopping   &&  // check: no car to the right of me is waiting
     carState[(i+1)%4] != onCrossing &&  // checks no cars on crossing,  
     carState[(i+2)%4] != onCrossing &&  // nicer solution possible, but to
     carState[(i+3)%4] != onCrossing     // do it in a safe way, we need the next lecture 
                   -> carState[i] = onCrossing
  }
  carState[i] = far;
}

active proctype noTwoCarsOnCrossing() {
  byte car1, car2;
  select(car1: 0..3) // NR_CARS
  select(car2: 0..3) // NR_CARS
  assert (carState[car1] != onCrossing || carState[car2] != onCrossing || car1 == car2)  
}

// c) to introduce a bug, comment e.g. out the line 'carState[(i+2)%4] != onCrossing' in proctype car()
// you should then get a counterexample where two cars are on a crossing

// d) Comment in the process below to check whether the model allows two cars to wait at a crossing at the same time
// The verification should fail with a counterexample showing two cars waiting
// The assert statement expresses that when choosing two different cars then one of them must not wait at the crossing
// If the assertion is violated, i.e., our model allows two cars to wait at the crossing at the same time and
// the counterexample shows one of these cases
/*
active proctype sanityCheck() {
  byte car1, car2;
  select(car1: 0..3) // NR_CARS
  select(car2: 0..3) // NR_CARS
  assert (car1 == car2 || carState[car1] != stopping || carState[car2] != stopping)  
}
*/

init {
  byte i;
  atomic {
    for (i : 0..3) { 
        run car(i)
    }
  }
}